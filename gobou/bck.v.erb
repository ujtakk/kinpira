% load "parameters.rb"
% $d_pixelbuf = 32

module ctrl_core(/*AUTOARG*/);
`include "parameters.vh"

  parameter S_WAIT    = 'd0;
  parameter S_WEIGHT  = 'd1;
  parameter S_BIAS    = 'd2;
  parameter S_OUTPUT  = 'd3;

  /*AUTOINPUT*/
  input clk;
  input xrst;
  input req;
  input in_begin;
  input in_valid;
  input in_end;
  input [IMGSIZE-1:0] img_addr;
  input [NETSIZE-1:0] net_addr;
  input [LWIDTH-1:0]  total_out;
  input [LWIDTH-1:0]  total_in;

  /*AUTOOUTPUT*/
  output                ack;
  output                out_begin;
  output                out_valid;
  output                out_end;
  output                mem_img_we;
  output [IMGSIZE-1:0]  mem_img_addr;
  output [NETSIZE-1:0]  mem_net_addr;

  /*AUTOWIRE*/
  wire s_weight_end;
  wire s_bias_end;
  wire s_output_end;
  wire final_iter;

  /*AUTOREG*/
  reg [2-1:0]       r_state;
  reg               r_ack;
  reg [LWIDTH-1:0]  r_total_out;
  reg [LWIDTH-1:0]  r_total_in;
  reg [LWIDTH-1:0]  r_count_out;
  reg [LWIDTH-1:0]  r_count_in;
  reg               r_out_begin;
  reg               r_out_valid;
  reg               r_out_end;

  assign out_begin = r_out_begin;
  assign out_valid = r_out_valid;
  assign out_end = r_out_end;
  assign mem_img_we = r_img_we;
  assign mem_img_addr = ;
  assign mem_net_addr = ;
  assign ack = r_ack;

  assign s_weight_end = r_state == S_WEIGHT && r_count_in == r_total_in - 1;
  assign s_bias_end   = r_state == S_BIAS;
  assign s_output_end = r_state == S_OUTPUT && in_end;
  assign final_iter = r_count_in == r_total_in - 1
                   && r_count_out >= r_total_out - CORE;

  always @(posedge clk)
    if (!xrst)
    begin
      r_state <= S_WAIT;
      r_count_out <= 0;
      r_count_in <= 0;
    end
    else
      case (r_state)
        S_WAIT:
          if (req)
            r_state <= S_BIAS;

        S_WEIGHT:
          if (s_weight_end)
          begin
            r_state <= S_BIAS;
            r_count_in <= 0;
          end
          else
            r_count_in <= r_count_in + 1;

        S_BIAS:
          if (s_bias_end)
            r_state <= S_OUTPUT;

        S_OUTPUT:
          if (s_output_end)
            if (r_count_out >= r_total_out - CORE)
            begin
              r_state <= S_WAIT;
              r_count_out <= 0;
            end
            else
            begin
              r_state <= S_WEIGHT;
              r_count_out <= r_count_out + CORE;
            end

        default:
          r_state <= S_WAIT;
      endcase

  always @(posedge clk)
    if (!xrst)
    begin
      r_total_in    <= 0;
      r_total_out   <= 0;
    end
    else if (r_state == S_WAIT && req)
    begin
      r_total_in    <= total_in;
      r_total_out   <= total_out;
    end

  always @(posedge clk)
    if (!xrst)
      r_ack <= 1;
    else if (req)
      r_ack <= 0;
    else if (s_output_end && r_count_out >= r_total_out - CORE)
      r_ack <= 1;

  always @(posedge clk)
    if (!xrst)
    begin
      r_weight_addr <= 0;
      r_bias_addr   <= 0;
    end
    else if (final_iter)
    begin
      r_weight_addr <= 0;
      r_bias_addr   <= 0;
    end
    else if (r_state == S_WEIGHT)
      r_weight_addr <= r_weight_addr + 1;
    else if (r_state == S_BIAS)
      r_bias_addr <= r_bias_addr + 1;

  always @(posedge clk)
    if (!xrst)
    begin
      r_weight_offset <= 0;
      r_bias_offset   <= 0;
    end
    else if (req || ack)
    begin
      r_weight_offset <= weight_addr;
      r_bias_offset   <= bias_addr;
    end

  always @(posedge clk)
    if (!xrst)
      r_input_addr <= 0;
    else if (r_state == S_BIAS)
      r_input_addr <= 0;
    else if (r_state == S_WEIGHT)
      r_input_addr <= r_input_addr + 1;

  always @(posedge clk)
    if (!xrst)
      r_output_we <= 0;
    else
      r_output_we <= r_state == S_OUTPUT
                  && in_valid;

  always @(posedge clk)
    if (!xrst)
      r_output_addr <= 0;
    else if (ack)
      r_output_addr <= 0;
    else if (mem_output_we)
      r_output_addr <= r_output_addr + 1;

  <%- for n in ["begin", "valid", "end"] -%>
  always @(posedge clk)
    if (!xrst)
      r_out_<%=n%> <= 0;
    else
      <%- case n -%>
      <%- when "begin" -%>
      r_out_begin <= req
                  || s_weight_end && (r_count_in != r_total_in - 1);
      <%- when "valid" -%>
      r_out_valid <= (r_state == S_BIAS || r_state == S_WEIGHT);
      <%- when "end" -%>
      r_out_end   <= s_weight_end;
      <%- else -%>
      <%- end -%>
  <%- end -%>

endmodule

